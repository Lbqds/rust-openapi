/*
 * Alephium API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.15.2
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`delete_wallets_wallet_name`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteWalletsWalletNameError {
    Status400(models::BadRequest),
    Status401(models::Unauthorized),
    Status404(models::NotFound),
    Status500(models::InternalServerError),
    Status503(models::ServiceUnavailable),
    Status504(models::GatewayTimeout),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_wallets`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetWalletsError {
    Status400(models::BadRequest),
    Status401(models::Unauthorized),
    Status404(models::NotFound),
    Status500(models::InternalServerError),
    Status503(models::ServiceUnavailable),
    Status504(models::GatewayTimeout),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_wallets_wallet_name`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetWalletsWalletNameError {
    Status400(models::BadRequest),
    Status401(models::Unauthorized),
    Status404(models::NotFound),
    Status500(models::InternalServerError),
    Status503(models::ServiceUnavailable),
    Status504(models::GatewayTimeout),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_wallets_wallet_name_addresses`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetWalletsWalletNameAddressesError {
    Status400(models::BadRequest),
    Status401(models::Unauthorized),
    Status404(models::NotFound),
    Status500(models::InternalServerError),
    Status503(models::ServiceUnavailable),
    Status504(models::GatewayTimeout),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_wallets_wallet_name_addresses_address`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetWalletsWalletNameAddressesAddressError {
    Status400(models::BadRequest),
    Status401(models::Unauthorized),
    Status404(models::NotFound),
    Status500(models::InternalServerError),
    Status503(models::ServiceUnavailable),
    Status504(models::GatewayTimeout),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_wallets_wallet_name_balances`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetWalletsWalletNameBalancesError {
    Status400(models::BadRequest),
    Status401(models::Unauthorized),
    Status404(models::NotFound),
    Status500(models::InternalServerError),
    Status503(models::ServiceUnavailable),
    Status504(models::GatewayTimeout),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_wallets`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostWalletsError {
    Status400(models::BadRequest),
    Status401(models::Unauthorized),
    Status404(models::NotFound),
    Status500(models::InternalServerError),
    Status503(models::ServiceUnavailable),
    Status504(models::GatewayTimeout),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_wallets_wallet_name_change_active_address`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostWalletsWalletNameChangeActiveAddressError {
    Status400(models::BadRequest),
    Status401(models::Unauthorized),
    Status404(models::NotFound),
    Status500(models::InternalServerError),
    Status503(models::ServiceUnavailable),
    Status504(models::GatewayTimeout),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_wallets_wallet_name_derive_next_address`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostWalletsWalletNameDeriveNextAddressError {
    Status400(models::BadRequest),
    Status401(models::Unauthorized),
    Status404(models::NotFound),
    Status500(models::InternalServerError),
    Status503(models::ServiceUnavailable),
    Status504(models::GatewayTimeout),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_wallets_wallet_name_lock`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostWalletsWalletNameLockError {
    Status400(models::BadRequest),
    Status401(models::Unauthorized),
    Status404(models::NotFound),
    Status500(models::InternalServerError),
    Status503(models::ServiceUnavailable),
    Status504(models::GatewayTimeout),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_wallets_wallet_name_reveal_mnemonic`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostWalletsWalletNameRevealMnemonicError {
    Status400(models::BadRequest),
    Status401(models::Unauthorized),
    Status404(models::NotFound),
    Status500(models::InternalServerError),
    Status503(models::ServiceUnavailable),
    Status504(models::GatewayTimeout),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_wallets_wallet_name_sign`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostWalletsWalletNameSignError {
    Status400(models::BadRequest),
    Status401(models::Unauthorized),
    Status404(models::NotFound),
    Status500(models::InternalServerError),
    Status503(models::ServiceUnavailable),
    Status504(models::GatewayTimeout),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_wallets_wallet_name_sweep_active_address`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostWalletsWalletNameSweepActiveAddressError {
    Status400(models::BadRequest),
    Status401(models::Unauthorized),
    Status404(models::NotFound),
    Status500(models::InternalServerError),
    Status503(models::ServiceUnavailable),
    Status504(models::GatewayTimeout),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_wallets_wallet_name_sweep_all_addresses`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostWalletsWalletNameSweepAllAddressesError {
    Status400(models::BadRequest),
    Status401(models::Unauthorized),
    Status404(models::NotFound),
    Status500(models::InternalServerError),
    Status503(models::ServiceUnavailable),
    Status504(models::GatewayTimeout),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_wallets_wallet_name_transfer`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostWalletsWalletNameTransferError {
    Status400(models::BadRequest),
    Status401(models::Unauthorized),
    Status404(models::NotFound),
    Status500(models::InternalServerError),
    Status503(models::ServiceUnavailable),
    Status504(models::GatewayTimeout),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_wallets_wallet_name_unlock`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostWalletsWalletNameUnlockError {
    Status400(models::BadRequest),
    Status401(models::Unauthorized),
    Status404(models::NotFound),
    Status500(models::InternalServerError),
    Status503(models::ServiceUnavailable),
    Status504(models::GatewayTimeout),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`put_wallets`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PutWalletsError {
    Status400(models::BadRequest),
    Status401(models::Unauthorized),
    Status404(models::NotFound),
    Status500(models::InternalServerError),
    Status503(models::ServiceUnavailable),
    Status504(models::GatewayTimeout),
    UnknownValue(serde_json::Value),
}


pub async fn delete_wallets_wallet_name(configuration: &configuration::Configuration, wallet_name: &str, password: &str) -> Result<(), Error<DeleteWalletsWalletNameError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_wallet_name = wallet_name;
    let p_password = password;

    let uri_str = format!("{}/wallets/{wallet_name}", configuration.base_path, wallet_name=crate::apis::urlencode(p_wallet_name));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    req_builder = req_builder.query(&[("password", &p_password.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteWalletsWalletNameError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_wallets(configuration: &configuration::Configuration, ) -> Result<Vec<models::WalletStatus>, Error<GetWalletsError>> {

    let uri_str = format!("{}/wallets", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::WalletStatus&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::WalletStatus&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetWalletsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_wallets_wallet_name(configuration: &configuration::Configuration, wallet_name: &str) -> Result<models::WalletStatus, Error<GetWalletsWalletNameError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_wallet_name = wallet_name;

    let uri_str = format!("{}/wallets/{wallet_name}", configuration.base_path, wallet_name=crate::apis::urlencode(p_wallet_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WalletStatus`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WalletStatus`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetWalletsWalletNameError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_wallets_wallet_name_addresses(configuration: &configuration::Configuration, wallet_name: &str) -> Result<models::Addresses, Error<GetWalletsWalletNameAddressesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_wallet_name = wallet_name;

    let uri_str = format!("{}/wallets/{wallet_name}/addresses", configuration.base_path, wallet_name=crate::apis::urlencode(p_wallet_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Addresses`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Addresses`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetWalletsWalletNameAddressesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_wallets_wallet_name_addresses_address(configuration: &configuration::Configuration, wallet_name: &str, address: &str) -> Result<models::AddressInfo, Error<GetWalletsWalletNameAddressesAddressError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_wallet_name = wallet_name;
    let p_address = address;

    let uri_str = format!("{}/wallets/{wallet_name}/addresses/{address}", configuration.base_path, wallet_name=crate::apis::urlencode(p_wallet_name), address=crate::apis::urlencode(p_address));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AddressInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AddressInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetWalletsWalletNameAddressesAddressError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_wallets_wallet_name_balances(configuration: &configuration::Configuration, wallet_name: &str) -> Result<models::Balances, Error<GetWalletsWalletNameBalancesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_wallet_name = wallet_name;

    let uri_str = format!("{}/wallets/{wallet_name}/balances", configuration.base_path, wallet_name=crate::apis::urlencode(p_wallet_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Balances`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Balances`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetWalletsWalletNameBalancesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// A new wallet will be created and respond with a mnemonic. Make sure to keep that mnemonic safely as it will allows you to recover your wallet. Default mnemonic size is 24, (options: 12, 15, 18, 21, 24).
pub async fn post_wallets(configuration: &configuration::Configuration, wallet_creation: models::WalletCreation) -> Result<models::WalletCreationResult, Error<PostWalletsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_wallet_creation = wallet_creation;

    let uri_str = format!("{}/wallets", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_wallet_creation);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WalletCreationResult`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WalletCreationResult`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostWalletsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn post_wallets_wallet_name_change_active_address(configuration: &configuration::Configuration, wallet_name: &str, change_active_address: models::ChangeActiveAddress) -> Result<(), Error<PostWalletsWalletNameChangeActiveAddressError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_wallet_name = wallet_name;
    let p_change_active_address = change_active_address;

    let uri_str = format!("{}/wallets/{wallet_name}/change-active-address", configuration.base_path, wallet_name=crate::apis::urlencode(p_wallet_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_change_active_address);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<PostWalletsWalletNameChangeActiveAddressError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Cannot be called from a miner wallet
pub async fn post_wallets_wallet_name_derive_next_address(configuration: &configuration::Configuration, wallet_name: &str, group: Option<i32>) -> Result<models::AddressInfo, Error<PostWalletsWalletNameDeriveNextAddressError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_wallet_name = wallet_name;
    let p_group = group;

    let uri_str = format!("{}/wallets/{wallet_name}/derive-next-address", configuration.base_path, wallet_name=crate::apis::urlencode(p_wallet_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_group {
        req_builder = req_builder.query(&[("group", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AddressInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AddressInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostWalletsWalletNameDeriveNextAddressError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn post_wallets_wallet_name_lock(configuration: &configuration::Configuration, wallet_name: &str) -> Result<(), Error<PostWalletsWalletNameLockError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_wallet_name = wallet_name;

    let uri_str = format!("{}/wallets/{wallet_name}/lock", configuration.base_path, wallet_name=crate::apis::urlencode(p_wallet_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<PostWalletsWalletNameLockError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn post_wallets_wallet_name_reveal_mnemonic(configuration: &configuration::Configuration, wallet_name: &str, reveal_mnemonic: models::RevealMnemonic) -> Result<models::RevealMnemonicResult, Error<PostWalletsWalletNameRevealMnemonicError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_wallet_name = wallet_name;
    let p_reveal_mnemonic = reveal_mnemonic;

    let uri_str = format!("{}/wallets/{wallet_name}/reveal-mnemonic", configuration.base_path, wallet_name=crate::apis::urlencode(p_wallet_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_reveal_mnemonic);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RevealMnemonicResult`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RevealMnemonicResult`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostWalletsWalletNameRevealMnemonicError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn post_wallets_wallet_name_sign(configuration: &configuration::Configuration, wallet_name: &str, sign: models::Sign) -> Result<models::SignResult, Error<PostWalletsWalletNameSignError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_wallet_name = wallet_name;
    let p_sign = sign;

    let uri_str = format!("{}/wallets/{wallet_name}/sign", configuration.base_path, wallet_name=crate::apis::urlencode(p_wallet_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_sign);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SignResult`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SignResult`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostWalletsWalletNameSignError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn post_wallets_wallet_name_sweep_active_address(configuration: &configuration::Configuration, wallet_name: &str, sweep: models::Sweep) -> Result<models::TransferResults, Error<PostWalletsWalletNameSweepActiveAddressError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_wallet_name = wallet_name;
    let p_sweep = sweep;

    let uri_str = format!("{}/wallets/{wallet_name}/sweep-active-address", configuration.base_path, wallet_name=crate::apis::urlencode(p_wallet_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_sweep);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TransferResults`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TransferResults`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostWalletsWalletNameSweepActiveAddressError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn post_wallets_wallet_name_sweep_all_addresses(configuration: &configuration::Configuration, wallet_name: &str, sweep: models::Sweep) -> Result<models::TransferResults, Error<PostWalletsWalletNameSweepAllAddressesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_wallet_name = wallet_name;
    let p_sweep = sweep;

    let uri_str = format!("{}/wallets/{wallet_name}/sweep-all-addresses", configuration.base_path, wallet_name=crate::apis::urlencode(p_wallet_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_sweep);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TransferResults`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TransferResults`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostWalletsWalletNameSweepAllAddressesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn post_wallets_wallet_name_transfer(configuration: &configuration::Configuration, wallet_name: &str, transfer: models::Transfer) -> Result<models::TransferResult, Error<PostWalletsWalletNameTransferError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_wallet_name = wallet_name;
    let p_transfer = transfer;

    let uri_str = format!("{}/wallets/{wallet_name}/transfer", configuration.base_path, wallet_name=crate::apis::urlencode(p_wallet_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_transfer);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TransferResult`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TransferResult`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostWalletsWalletNameTransferError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn post_wallets_wallet_name_unlock(configuration: &configuration::Configuration, wallet_name: &str, wallet_unlock: models::WalletUnlock) -> Result<(), Error<PostWalletsWalletNameUnlockError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_wallet_name = wallet_name;
    let p_wallet_unlock = wallet_unlock;

    let uri_str = format!("{}/wallets/{wallet_name}/unlock", configuration.base_path, wallet_name=crate::apis::urlencode(p_wallet_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_wallet_unlock);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<PostWalletsWalletNameUnlockError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn put_wallets(configuration: &configuration::Configuration, wallet_restore: models::WalletRestore) -> Result<models::WalletRestoreResult, Error<PutWalletsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_wallet_restore = wallet_restore;

    let uri_str = format!("{}/wallets", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_wallet_restore);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WalletRestoreResult`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WalletRestoreResult`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PutWalletsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

