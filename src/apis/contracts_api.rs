/*
 * Alephium API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.15.2
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`get_contracts_address_parent`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetContractsAddressParentError {
    Status400(models::BadRequest),
    Status401(models::Unauthorized),
    Status404(models::NotFound),
    Status500(models::InternalServerError),
    Status503(models::ServiceUnavailable),
    Status504(models::GatewayTimeout),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_contracts_address_state`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetContractsAddressStateError {
    Status400(models::BadRequest),
    Status401(models::Unauthorized),
    Status404(models::NotFound),
    Status500(models::InternalServerError),
    Status503(models::ServiceUnavailable),
    Status504(models::GatewayTimeout),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_contracts_address_sub_contracts`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetContractsAddressSubContractsError {
    Status400(models::BadRequest),
    Status401(models::Unauthorized),
    Status404(models::NotFound),
    Status500(models::InternalServerError),
    Status503(models::ServiceUnavailable),
    Status504(models::GatewayTimeout),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_contracts_address_sub_contracts_current_count`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetContractsAddressSubContractsCurrentCountError {
    Status400(models::BadRequest),
    Status401(models::Unauthorized),
    Status404(models::NotFound),
    Status500(models::InternalServerError),
    Status503(models::ServiceUnavailable),
    Status504(models::GatewayTimeout),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_contracts_codehash_code`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetContractsCodehashCodeError {
    Status400(models::BadRequest),
    Status401(models::Unauthorized),
    Status404(models::NotFound),
    Status500(models::InternalServerError),
    Status503(models::ServiceUnavailable),
    Status504(models::GatewayTimeout),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_contracts_call_contract`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostContractsCallContractError {
    Status400(models::BadRequest),
    Status401(models::Unauthorized),
    Status404(models::NotFound),
    Status500(models::InternalServerError),
    Status503(models::ServiceUnavailable),
    Status504(models::GatewayTimeout),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_contracts_call_tx_script`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostContractsCallTxScriptError {
    Status400(models::BadRequest),
    Status401(models::Unauthorized),
    Status404(models::NotFound),
    Status500(models::InternalServerError),
    Status503(models::ServiceUnavailable),
    Status504(models::GatewayTimeout),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_contracts_compile_contract`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostContractsCompileContractError {
    Status400(models::BadRequest),
    Status401(models::Unauthorized),
    Status404(models::NotFound),
    Status500(models::InternalServerError),
    Status503(models::ServiceUnavailable),
    Status504(models::GatewayTimeout),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_contracts_compile_project`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostContractsCompileProjectError {
    Status400(models::BadRequest),
    Status401(models::Unauthorized),
    Status404(models::NotFound),
    Status500(models::InternalServerError),
    Status503(models::ServiceUnavailable),
    Status504(models::GatewayTimeout),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_contracts_compile_script`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostContractsCompileScriptError {
    Status400(models::BadRequest),
    Status401(models::Unauthorized),
    Status404(models::NotFound),
    Status500(models::InternalServerError),
    Status503(models::ServiceUnavailable),
    Status504(models::GatewayTimeout),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_contracts_multicall_contract`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostContractsMulticallContractError {
    Status400(models::BadRequest),
    Status401(models::Unauthorized),
    Status404(models::NotFound),
    Status500(models::InternalServerError),
    Status503(models::ServiceUnavailable),
    Status504(models::GatewayTimeout),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_contracts_test_contract`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostContractsTestContractError {
    Status400(models::BadRequest),
    Status401(models::Unauthorized),
    Status404(models::NotFound),
    Status500(models::InternalServerError),
    Status503(models::ServiceUnavailable),
    Status504(models::GatewayTimeout),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_contracts_unsigned_tx_deploy_contract`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostContractsUnsignedTxDeployContractError {
    Status400(models::BadRequest),
    Status401(models::Unauthorized),
    Status404(models::NotFound),
    Status500(models::InternalServerError),
    Status503(models::ServiceUnavailable),
    Status504(models::GatewayTimeout),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_contracts_unsigned_tx_execute_script`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostContractsUnsignedTxExecuteScriptError {
    Status400(models::BadRequest),
    Status401(models::Unauthorized),
    Status404(models::NotFound),
    Status500(models::InternalServerError),
    Status503(models::ServiceUnavailable),
    Status504(models::GatewayTimeout),
    UnknownValue(serde_json::Value),
}


pub async fn get_contracts_address_parent(configuration: &configuration::Configuration, address: &str) -> Result<String, Error<GetContractsAddressParentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_address = address;

    let uri_str = format!("{}/contracts/{address}/parent", configuration.base_path, address=crate::apis::urlencode(p_address));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `String`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `String`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetContractsAddressParentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_contracts_address_state(configuration: &configuration::Configuration, address: &str) -> Result<models::ContractState, Error<GetContractsAddressStateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_address = address;

    let uri_str = format!("{}/contracts/{address}/state", configuration.base_path, address=crate::apis::urlencode(p_address));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ContractState`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ContractState`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetContractsAddressStateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_contracts_address_sub_contracts(configuration: &configuration::Configuration, address: &str, start: i32, limit: Option<i32>) -> Result<models::SubContracts, Error<GetContractsAddressSubContractsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_address = address;
    let p_start = start;
    let p_limit = limit;

    let uri_str = format!("{}/contracts/{address}/sub-contracts", configuration.base_path, address=crate::apis::urlencode(p_address));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("start", &p_start.to_string())]);
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SubContracts`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SubContracts`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetContractsAddressSubContractsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_contracts_address_sub_contracts_current_count(configuration: &configuration::Configuration, address: &str) -> Result<i32, Error<GetContractsAddressSubContractsCurrentCountError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_address = address;

    let uri_str = format!("{}/contracts/{address}/sub-contracts/current-count", configuration.base_path, address=crate::apis::urlencode(p_address));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `i32`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `i32`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetContractsAddressSubContractsCurrentCountError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_contracts_codehash_code(configuration: &configuration::Configuration, code_hash: &str) -> Result<String, Error<GetContractsCodehashCodeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_code_hash = code_hash;

    let uri_str = format!("{}/contracts/{codeHash}/code", configuration.base_path, codeHash=crate::apis::urlencode(p_code_hash));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `String`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `String`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetContractsCodehashCodeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn post_contracts_call_contract(configuration: &configuration::Configuration, call_contract: models::CallContract) -> Result<models::CallContractResult, Error<PostContractsCallContractError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_call_contract = call_contract;

    let uri_str = format!("{}/contracts/call-contract", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_call_contract);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CallContractResult`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CallContractResult`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostContractsCallContractError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn post_contracts_call_tx_script(configuration: &configuration::Configuration, call_tx_script: models::CallTxScript) -> Result<models::CallTxScriptResult, Error<PostContractsCallTxScriptError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_call_tx_script = call_tx_script;

    let uri_str = format!("{}/contracts/call-tx-script", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_call_tx_script);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CallTxScriptResult`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CallTxScriptResult`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostContractsCallTxScriptError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn post_contracts_compile_contract(configuration: &configuration::Configuration, contract: models::Contract) -> Result<models::CompileContractResult, Error<PostContractsCompileContractError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_contract = contract;

    let uri_str = format!("{}/contracts/compile-contract", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_contract);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CompileContractResult`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CompileContractResult`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostContractsCompileContractError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn post_contracts_compile_project(configuration: &configuration::Configuration, project: models::Project) -> Result<models::CompileProjectResult, Error<PostContractsCompileProjectError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_project = project;

    let uri_str = format!("{}/contracts/compile-project", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_project);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CompileProjectResult`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CompileProjectResult`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostContractsCompileProjectError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn post_contracts_compile_script(configuration: &configuration::Configuration, script: models::Script) -> Result<models::CompileScriptResult, Error<PostContractsCompileScriptError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_script = script;

    let uri_str = format!("{}/contracts/compile-script", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_script);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CompileScriptResult`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CompileScriptResult`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostContractsCompileScriptError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn post_contracts_multicall_contract(configuration: &configuration::Configuration, multiple_call_contract: models::MultipleCallContract) -> Result<models::MultipleCallContractResult, Error<PostContractsMulticallContractError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_multiple_call_contract = multiple_call_contract;

    let uri_str = format!("{}/contracts/multicall-contract", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_multiple_call_contract);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MultipleCallContractResult`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MultipleCallContractResult`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostContractsMulticallContractError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn post_contracts_test_contract(configuration: &configuration::Configuration, test_contract: models::TestContract) -> Result<models::TestContractResult, Error<PostContractsTestContractError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_test_contract = test_contract;

    let uri_str = format!("{}/contracts/test-contract", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_test_contract);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TestContractResult`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TestContractResult`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostContractsTestContractError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn post_contracts_unsigned_tx_deploy_contract(configuration: &configuration::Configuration, build_deploy_contract_tx: models::BuildDeployContractTx) -> Result<models::BuildDeployContractTxResult, Error<PostContractsUnsignedTxDeployContractError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_build_deploy_contract_tx = build_deploy_contract_tx;

    let uri_str = format!("{}/contracts/unsigned-tx/deploy-contract", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_build_deploy_contract_tx);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BuildDeployContractTxResult`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BuildDeployContractTxResult`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostContractsUnsignedTxDeployContractError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn post_contracts_unsigned_tx_execute_script(configuration: &configuration::Configuration, build_execute_script_tx: models::BuildExecuteScriptTx) -> Result<models::BuildExecuteScriptTxResult, Error<PostContractsUnsignedTxExecuteScriptError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_build_execute_script_tx = build_execute_script_tx;

    let uri_str = format!("{}/contracts/unsigned-tx/execute-script", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_build_execute_script_tx);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BuildExecuteScriptTxResult`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BuildExecuteScriptTxResult`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostContractsUnsignedTxExecuteScriptError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

